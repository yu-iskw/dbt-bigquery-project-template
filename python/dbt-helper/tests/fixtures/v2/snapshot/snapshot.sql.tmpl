-- It was generated by dbt-helper=={{ dbt_helper_version }}.
-- THIS_IS_MY_CUSTOM_TEMPLATE
{% raw %}
{#
Please carefully design a dbt snapshot, because dbt can't rebuild snapshots.
Once we have created a dbt snapshot, we can't apply changes to the table.
Even `full_refresh=true` doesn't work.

If we really have to rebuild a snapshot, please use `drop_statement` with `pre_hook`.
We run a schedule job adding the drop statement and then remove the drop statement.
The scheduled job of the snapshot will be surely failed with the drop statement.
But there is no other way to reset the table.
#}
{% endraw %}
{{ '{%% snapshot %s %%}' | format(reference_id) }}

{{ '{%% set gcp_project = var("projects")["dev_project_id"] | default(var("projects")["%s"], True) %%}' | format(project_alias) }}
{{ '{%% set snapshot_owner = "%s" %%}' | format(owner) }}

{{ '{%% set drop_statement = "DROP TABLE `%%s`.`%s`.`%s`" | format(gcp_project) %%}' | format(dataset, table) }}

{% raw %}
{{
{%- endraw %}
  config(
    enabled=true,
    owner=snapshot_owner,
    persist_docs={"relation": true, "columns": true},
    strategy="{{- strategy -}}",
    target_database=gcp_project,
    target_schema="{{ dataset }}",
    pre_hook=[],
    alias="{{- table -}}",
    unique_key="TODO set unique_key"
    updated_at="TODO set updated_at",
    partition_by={
      'field': 'TODO set field if necessary',
      'data_type': '<timestamp | date | datetime | int64 >'
    },
    cluster_by=["TODO set cluster_by if necessary"],
    labels={
      "modeled": "dbt",
      "contains_pii": "<false | true>",
      "owner": snapshot_owner,
      {% for k, v in labels.items() -%}
      "{{- k -}}": "{{- v -}}",
      {% endfor -%}
    },
    tags=[
      {% for tag in tags -%}
       '{{ tag }}',
      {% endfor -%}
    ],
  )
{% raw -%}
}}

SELECT ...

{% endsnapshot %}
{%- endraw %}
